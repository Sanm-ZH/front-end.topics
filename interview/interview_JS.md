### JS面试题
1. **介绍js的基本数据类型**
    > Undefined、Null、Boolean、Number、String

2. **谈一谈let与var的区别？**
    > let命令不存在变量提升，如果在let前使用，会导致报错
如果块区中存在let和const命令，就会形成封闭作用域
不允许重复声明，因此，不能在函数内部重新声明参数

3. **闭包**

    闭包就是能够读取其他函数内部变量的函数闭包是指有权访问另一个函数作用域中变量的
    函数，创建闭包的最常见的方式就是在一个函数内创建另一个函数，
    通过另一个函数访问这个函数的局部变量,利用闭包可以突破作用链域
    
    - 闭包的特性：

    >函数内再嵌套函数
    内部函数可以引用外层的参数和变量
    参数和变量不会被垃圾回收机制回收
    说说你对闭包的理解
    使用闭包主要是为了设计私有的方法和变量。闭包的优点是可以避免全局变量的污染，缺点是闭包会常驻内存，会增大内存使用量，使用不当很容易造成内存泄露。在js中，函数即闭包，只有函数才会产生作用域的概念
    闭包 的最大用处有两个，一个是可以读取函数内部的变量，另一个就是让
    这些变量始终保持在内存中

    - 闭包的另一个用处，是封装对象的私有属性和私有方法
    ---
    - **好处**：能够实现封装和缓存等；
    - **坏处**：就是消耗内存、不正当使用会造成内存溢出的问题

    使用闭包的注意点
    
    > 由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则   会造成网页的性能问题，在IE中可能导致内存泄露<br>
      **解决方法是，在退出函数之前，将不使用的局部变量全部删除**

4. **实现一个深拷贝（思路）（考察频率：中）**
 
    > 对象中可能又存在对象，所以需要深拷贝。首先需要知道这是一个递归调用，然后要判断一些特殊类型（数组，正则对象，函数）进行具体的操作，可以通过Object.prototype.toString.call(obj)进行判断。

5. **call,apply,bind的区别**
    - 共同点：都是在调用时，动态指定函数中的this
    - 不同点：1.call，apply借用，临时绑定；2.bind 永久绑定

    **返回值**：<br>
    1. call，apply不创建新函数，仅调用原函数；<br>
    2. bind基于原函数，创建新函数对象，之后调用的其实是新函数对象
    
    **参数**：<br>
    
    1. call，apply在调用的时候传入所有参数call，要求独立传入每个参数，apply，要求将参数放入数组，统一传入；<br>
    2. bind可在创建函数提前绑定部分参数，调用函数时传递剩余参数。

6. **["1", "2", "3"].map(parseInt) 答案是多少？**
    > [1, NaN, NaN]因为 parseInt 需要两个参数 (val, radix)，其中radix 表示解析时用的基数。<br>
    map传了 3个(element, index, array)，对应的 radix 不合法导致解析失败。

7. **说说对防抖节流的理解（手写防抖函数）附加一个手写数组去重**<br>
    - 防抖：
    理解：在车站上车，人员上满了车才发走重点是人员上满触发一次。
    场景：实时搜索，拖拽。
    实现： //每一次都要清空定时器，重新设置上计时器值，使得计时器每一次都重新开始，直到最后满足条件并且等待delay时间后，才开始执行handler函数。
    ```js
    function debunce（handler，delay）{ 
      //handler是要传入的进行防抖的函数，delay是等待时间。   
       var timer = null;
       return function（）{   
            var _self = this，
            args = arguments;  
            clearTimeout（timer）;        //每次都要清除这个定时器       
            timer = setTimeout（function（）{    //重新开启定时器                        
                             handler.apply（_self，args）;    
                         }，delay）;     } 
    
    ```
    - 节流：
    理解：大于等于10分钟发一次车，重点是一定间隔时间就会触发一次。 （即预定一个函数只有在大于等于执行周期时才会执行，周期内不执行）。
    场景：窗口调整（调整大小），页面滚动（滚动），抢购时疯狂点击（鼠标按下）
    实现： //处理程序是要传入的进行节流的函数，wait是上述的间隔时间。 //使用时间戳进行时间的计算。
    ```js
       function throttle（handler，wait）{
         //handler是要进行节流的函数，wait是等待时间        
             var lastTime = 0;  
             return function(){     
                      var nowTime = new Date（).getTime（）;    //获取当前时间              
                      if（nowTime - lastTime> wait）{      
                               handler.apply（this，arguments）;      
                               lastTime = nowTime;      //更新最后时间            
                       }           
                }
      }
    
    ```

1. **谈谈你对webpack的看法**<br>
`WebPack` 是一个模块打包工具，你可以使用WebPack管理你的模块依赖，并编绎输出模块们所需的静态文件。它能够很好地管理、打包Web开发中所用到的`HTML`、`Javascript`、`CSS`以及各种静态文件（图片、字体等），让开发过程更加高效。对于不同类型的资源，webpack有对应的模块加载器。`webpack`模块打包器会分析模块间的依赖关系，最后 生成了优化且合并后的静态资源

1. **用过哪些设计模式？**<br>
- 工厂模式
    > 工厂模式解决了重复实例化的问题，但还有一个问题,那就是识别问题，因为根本无法
    主要好处就是可以消除对象间的耦合，通过使用工程方法而不是new关键字
- 构造函数模式
    > 使用构造函数的方法，即解决了重复实例化的问题，又解决了对象识别的问题，该模式与工厂模式的不同之处在于
    直接将属性和方法赋值给 this对象